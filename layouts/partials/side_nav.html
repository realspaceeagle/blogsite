<!-- Scroll progress indicator -->
<div class="scroll-progress" id="scroll-progress"></div>

<!-- Scroll to top button -->
<button class="scroll-to-top" id="scroll-to-top" aria-label="Scroll to top">
  ↑
</button>

<!-- Side Navigation for Table of Contents -->
<nav class="side-nav" id="side-nav">
  <div class="side-nav-content">
    <div class="side-nav-title" id="toc-title">Contents</div>
    <ul class="side-nav-list" id="toc-list">
      <!-- TOC will be populated by JavaScript -->
    </ul>
  </div>
</nav>

<script>
document.addEventListener('DOMContentLoaded', function() {
  const sideNav = document.getElementById('side-nav');
  const tocList = document.getElementById('toc-list');
  
  // Only show on blog post pages (not about, contact, etc.)
  const isPostPage = window.location.pathname.includes('/posts/');
  const headings = document.querySelectorAll('.post-content h1, .post-content h2, .post-content h3, .post-content h4, .post-content h5, .post-content h6');
  
  if (isPostPage && headings.length > 0) {
    sideNav.style.display = 'block';
    document.body.classList.add('side-nav-active');
    
    const toc = [];
    
    headings.forEach((heading, index) => {
      // Create or use existing ID
      let id = heading.id;
      if (!id) {
        // Generate ID from text content
        id = heading.textContent.trim()
          .toLowerCase()
          .replace(/[^\w\s-]/g, '') // Remove special characters
          .replace(/\s+/g, '-') // Replace spaces with hyphens
          .replace(/-+/g, '-') // Replace multiple hyphens with single
          .replace(/^-|-$/g, ''); // Remove leading/trailing hyphens
        
        // Ensure uniqueness
        let baseId = id;
        let counter = 1;
        while (document.getElementById(id)) {
          id = `${baseId}-${counter}`;
          counter++;
        }
        
        heading.id = id;
      }
      
      const level = parseInt(heading.tagName.substring(1));
      const text = heading.textContent.trim();
      
      toc.push({
        id: id,
        level: level,
        text: text,
        element: heading
      });
    });
    
    // Build collapsible nested TOC HTML structure
    function buildNestedTOC(items, minLevel = null, isTopLevel = true) {
      if (items.length === 0) return '';
      
      if (minLevel === null) {
        minLevel = Math.min(...items.map(item => item.level));
      }
      
      let html = '';
      let i = 0;
      
      while (i < items.length) {
        const item = items[i];
        
        if (item.level === minLevel) {
          // Look for nested items first to determine if we need expand/collapse
          const nestedItems = [];
          let j = i + 1;
          
          while (j < items.length && items[j].level > minLevel) {
            nestedItems.push(items[j]);
            j++;
          }
          
          const hasChildren = nestedItems.length > 0;
          const expandIcon = hasChildren ? '<span class="toc-expand">▶</span>' : '';
          
          html += `<li class="toc-item toc-level-${item.level}${hasChildren ? ' has-children' : ''}">
            <div class="toc-item-wrapper">
              ${expandIcon}
              <a href="#${item.id}" class="toc-link" data-target="${item.id}">${item.text}</a>
            </div>`;
          
          if (hasChildren) {
            html += `<ul class="toc-nested${isTopLevel ? ' collapsed' : ''}">${buildNestedTOC(nestedItems, null, false)}</ul>`;
          }
          
          html += '</li>';
          i = j;
        } else {
          i++;
        }
      }
      
      return html;
    }
    
    tocList.innerHTML = buildNestedTOC(toc);
    
    // Add click handlers for expand/collapse functionality
    const expandButtons = document.querySelectorAll('.toc-expand');
    expandButtons.forEach(button => {
      button.addEventListener('click', function(e) {
        e.preventDefault();
        e.stopPropagation();
        
        const listItem = this.closest('.toc-item');
        const nestedList = listItem.querySelector('.toc-nested');
        
        if (nestedList) {
          const isCollapsed = nestedList.classList.contains('collapsed');
          
          if (isCollapsed) {
            nestedList.classList.remove('collapsed');
            this.textContent = '▼';
            listItem.classList.add('expanded');
          } else {
            nestedList.classList.add('collapsed');
            this.textContent = '▶';
            listItem.classList.remove('expanded');
          }
        }
      });
    });
    
    // Add click handlers for smooth scrolling
    const tocLinks = document.querySelectorAll('.toc-link');
    tocLinks.forEach(link => {
      link.addEventListener('click', function(e) {
        e.preventDefault();
        const targetId = this.getAttribute('data-target');
        const targetElement = document.getElementById(targetId);
        
        if (targetElement) {
          targetElement.scrollIntoView({ 
            behavior: 'smooth',
            block: 'start'
          });
          
          // Update active link
          tocLinks.forEach(l => l.classList.remove('active'));
          this.classList.add('active');
          
          // Auto-expand parent sections when navigating to a nested heading
          const parentItem = this.closest('.toc-item').parentElement.closest('.toc-item');
          if (parentItem && parentItem.classList.contains('has-children')) {
            const parentNestedList = parentItem.querySelector('.toc-nested');
            const parentExpandButton = parentItem.querySelector('.toc-expand');
            
            if (parentNestedList && parentNestedList.classList.contains('collapsed')) {
              parentNestedList.classList.remove('collapsed');
              if (parentExpandButton) {
                parentExpandButton.textContent = '▼';
              }
              parentItem.classList.add('expanded');
            }
          }
        }
      });
    });
    
    // Simple scroll tracking for active highlighting
    function updateActiveLink() {
      const scrollPosition = window.scrollY + 100;
      let activeHeading = null;
      
      // Find the currently visible heading
      headings.forEach(heading => {
        const rect = heading.getBoundingClientRect();
        const absoluteTop = rect.top + window.pageYOffset;
        
        if (absoluteTop <= scrollPosition) {
          activeHeading = heading;
        }
      });
      
      // Update active state
      tocLinks.forEach(link => {
        link.classList.remove('active');
        if (activeHeading && link.getAttribute('data-target') === activeHeading.id) {
          link.classList.add('active');
        }
      });
    }
    
    // Throttled scroll handler
    let scrollTimeout;
    window.addEventListener('scroll', function() {
      if (scrollTimeout) {
        clearTimeout(scrollTimeout);
      }
      scrollTimeout = setTimeout(updateActiveLink, 10);
    });
    
    // Initialize active link
    updateActiveLink();
    
  } else {
    sideNav.style.display = 'none';
    document.body.classList.remove('side-nav-active');
  }
  
  // Enhanced scroll functionality
  const scrollProgress = document.getElementById('scroll-progress');
  const scrollToTopBtn = document.getElementById('scroll-to-top');
  
  // Scroll progress indicator
  function updateScrollProgress() {
    const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
    const scrollHeight = document.documentElement.scrollHeight - document.documentElement.clientHeight;
    const scrollPercent = (scrollTop / scrollHeight) * 100;
    
    if (scrollProgress) {
      scrollProgress.style.width = scrollPercent + '%';
    }
    
    // Show/hide scroll to top button
    if (scrollToTopBtn) {
      if (scrollTop > 300) {
        scrollToTopBtn.classList.add('visible');
      } else {
        scrollToTopBtn.classList.remove('visible');
      }
    }
  }
  
  // Scroll to top functionality
  if (scrollToTopBtn) {
    scrollToTopBtn.addEventListener('click', function() {
      window.scrollTo({
        top: 0,
        behavior: 'smooth'
      });
    });
  }
  
  // Enhanced scroll listener with throttling
  let scrollTicking = false;
  function handleScroll() {
    if (!scrollTicking) {
      requestAnimationFrame(() => {
        updateScrollProgress();
        if (isPostPage && headings.length > 0) {
          updateActiveLink();
        }
        scrollTicking = false;
      });
      scrollTicking = true;
    }
  }
  
  // Replace the existing scroll listener
  window.removeEventListener('scroll', function() {
    if (scrollTimeout) {
      clearTimeout(scrollTimeout);
    }
    scrollTimeout = setTimeout(updateActiveLink, 10);
  });
  
  window.addEventListener('scroll', handleScroll);
  
  // Initialize scroll progress
  updateScrollProgress();
});
</script>
