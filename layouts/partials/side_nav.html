<!-- Side Navigation for Table of Contents -->
<nav class="side-nav" id="side-nav">
  <div class="side-nav-content">
    <div class="side-nav-title" id="toc-title">Contents</div>
    <ul class="side-nav-list" id="toc-list">
      <!-- TOC will be populated by JavaScript -->
    </ul>
  </div>
</nav>

<script>
document.addEventListener('DOMContentLoaded', function() {
  const sideNav = document.getElementById('side-nav');
  const tocList = document.getElementById('toc-list');
  
  // Only show on blog post pages (not about, contact, etc.)
  const isPostPage = window.location.pathname.includes('/posts/');
  const headings = document.querySelectorAll('.post-content h1, .post-content h2, .post-content h3, .post-content h4, .post-content h5, .post-content h6');
  
  if (isPostPage && headings.length > 0) {
    sideNav.style.display = 'block';
    document.body.classList.add('side-nav-active');
    
    const toc = [];
    
    headings.forEach((heading, index) => {
      // Create or use existing ID
      let id = heading.id;
      if (!id) {
        // Generate ID from text content
        id = heading.textContent.trim()
          .toLowerCase()
          .replace(/[^\w\s-]/g, '') // Remove special characters
          .replace(/\s+/g, '-') // Replace spaces with hyphens
          .replace(/-+/g, '-') // Replace multiple hyphens with single
          .replace(/^-|-$/g, ''); // Remove leading/trailing hyphens
        
        // Ensure uniqueness
        let baseId = id;
        let counter = 1;
        while (document.getElementById(id)) {
          id = `${baseId}-${counter}`;
          counter++;
        }
        
        heading.id = id;
      }
      
      const level = parseInt(heading.tagName.substring(1));
      const text = heading.textContent.trim();
      
      toc.push({
        id: id,
        level: level,
        text: text,
        element: heading
      });
    });
    
    // Build nested TOC HTML structure
    function buildNestedTOC(items, minLevel = null) {
      if (items.length === 0) return '';
      
      if (minLevel === null) {
        minLevel = Math.min(...items.map(item => item.level));
      }
      
      let html = '';
      let i = 0;
      
      while (i < items.length) {
        const item = items[i];
        
        if (item.level === minLevel) {
          html += `<li class="toc-item toc-level-${item.level}">
            <a href="#${item.id}" class="toc-link" data-target="${item.id}">${item.text}</a>`;
          
          // Look for nested items
          const nestedItems = [];
          let j = i + 1;
          
          while (j < items.length && items[j].level > minLevel) {
            nestedItems.push(items[j]);
            j++;
          }
          
          if (nestedItems.length > 0) {
            html += '<ul class="toc-nested">' + buildNestedTOC(nestedItems) + '</ul>';
          }
          
          html += '</li>';
          i = j;
        } else {
          i++;
        }
      }
      
      return html;
    }
    
    tocList.innerHTML = buildNestedTOC(toc);
    
    // Add has-nested class to items with nested lists
    document.querySelectorAll('.toc-item').forEach(item => {
      if (item.querySelector('.toc-nested')) {
        item.classList.add('has-nested');
      }
    });
    
    // Add click handlers for smooth scrolling
    const tocLinks = document.querySelectorAll('.toc-link');
    tocLinks.forEach(link => {
      link.addEventListener('click', function(e) {
        e.preventDefault();
        const targetId = this.getAttribute('data-target');
        const targetElement = document.getElementById(targetId);
        
        if (targetElement) {
          // Calculate offset for better positioning
          const headerHeight = 60; // Adjust based on your header height
          const extraOffset = 20; // Additional space for better reading
          const elementPosition = targetElement.getBoundingClientRect().top;
          const offsetPosition = elementPosition + window.pageYOffset - headerHeight - extraOffset;
          
          // Disable scroll tracking temporarily to prevent conflicts
          window.removeEventListener('scroll', handleScroll);
          
          window.scrollTo({
            top: Math.max(0, offsetPosition),
            behavior: 'smooth'
          });
          
          // Re-enable scroll tracking after smooth scroll completes
          setTimeout(() => {
            window.addEventListener('scroll', handleScroll, { passive: true });
            updateActiveLink(); // Update immediately after scroll
          }, 800);
          
          // Update active link immediately
          tocLinks.forEach(l => l.classList.remove('active'));
          this.classList.add('active');
        }
      });
    });
    
    // Simple and reliable scroll tracking
    function updateActiveLink() {
      const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
      const windowHeight = window.innerHeight;
      const offset = 150; // Offset from top for better UX
      
      let currentHeading = null;
      let currentSection = null;
      
      // Find the current heading (simple approach)
      for (let i = headings.length - 1; i >= 0; i--) {
        const heading = headings[i];
        const rect = heading.getBoundingClientRect();
        const elementTop = rect.top + scrollTop;
        
        if (elementTop <= scrollTop + offset) {
          currentHeading = heading;
          break;
        }
      }
      
      // If at top of page and no heading found, use first heading
      if (!currentHeading && scrollTop < 200 && headings.length > 0) {
        currentHeading = headings[0];
      }
      
      // Find current section (H2) for expansion
      if (currentHeading) {
        const level = parseInt(currentHeading.tagName.substring(1));
        if (level === 2) {
          currentSection = currentHeading;
        } else if (level > 2) {
          // Find the parent H2
          for (let i = Array.from(headings).indexOf(currentHeading) - 1; i >= 0; i--) {
            if (headings[i].tagName === 'H2') {
              currentSection = headings[i];
              break;
            }
          }
        }
      }
      
      // Update all TOC links
      tocLinks.forEach(link => {
        const targetId = link.getAttribute('data-target');
        const linkElement = document.getElementById(targetId);
        const isActive = currentHeading && targetId === currentHeading.id;
        
        // Update active state
        if (isActive) {
          link.classList.add('active');
        } else {
          link.classList.remove('active');
        }
        
        // Handle section expansion for H2 elements
        if (linkElement && linkElement.tagName === 'H2') {
          const parentItem = link.closest('.toc-item');
          const nestedList = parentItem ? parentItem.querySelector('.toc-nested') : null;
          
          if (nestedList) {
            const shouldExpand = currentSection && targetId === currentSection.id;
            
            if (shouldExpand) {
              nestedList.style.display = 'block';
              nestedList.style.opacity = '1';
              nestedList.style.maxHeight = 'none';
              parentItem.classList.add('expanded');
            } else {
              nestedList.style.display = 'none';
              nestedList.style.opacity = '0';
              nestedList.style.maxHeight = '0';
              parentItem.classList.remove('expanded');
            }
          }
        }
      });
      
      // Auto-scroll sidebar to keep active link visible
      if (currentHeading) {
        const activeLink = document.querySelector(`.toc-link[data-target="${currentHeading.id}"]`);
        if (activeLink) {
          const sideNavRect = sideNav.getBoundingClientRect();
          const linkRect = activeLink.getBoundingClientRect();
          
          // Check if link is outside visible area
          if (linkRect.top < sideNavRect.top + 50 || linkRect.bottom > sideNavRect.bottom - 50) {
            sideNav.scrollTo({
              top: sideNav.scrollTop + (linkRect.top - sideNavRect.top) - sideNavRect.height / 2,
              behavior: 'smooth'
            });
          }
        }
      }
    }
    
    // Simple throttled scroll handler
    let scrollTimeout;
    function handleScroll() {
      if (scrollTimeout) {
        clearTimeout(scrollTimeout);
      }
      scrollTimeout = setTimeout(updateActiveLink, 50);
    }
    
    // Add scroll listener
    window.addEventListener('scroll', handleScroll, { passive: true });
    
    // Initialize sections - collapse all except first
    function initializeSections() {
      const allSections = document.querySelectorAll('.toc-item');
      allSections.forEach((section, index) => {
        const nestedList = section.querySelector('.toc-nested');
        if (nestedList) {
          // Collapse all sections initially
          nestedList.style.display = 'none';
          nestedList.style.opacity = '0';
          nestedList.style.maxHeight = '0';
          section.classList.remove('expanded');
        }
      });
    }
    
    // Initialize sections and active link
    initializeSections();
    updateActiveLink();
    
  } else {
    sideNav.style.display = 'none';
    document.body.classList.remove('side-nav-active');
  }
});
</script>
