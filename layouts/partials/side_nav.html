<!-- Side Navigation for Table of Contents -->
<nav class="side-nav" id="side-nav">
  <div class="side-nav-content">
    <div class="side-nav-title" id="toc-title">Contents</div>
    <ul class="side-nav-list" id="toc-list">
      <!-- TOC will be populated by JavaScript -->
    </ul>
  </div>
</nav>

<script>
document.addEventListener('DOMContentLoaded', function() {
  const sideNav = document.getElementById('side-nav');
  const tocList = document.getElementById('toc-list');
  
  // Only show on blog post pages (not about, contact, etc.)
  const isPostPage = window.location.pathname.includes('/posts/');
  const headings = document.querySelectorAll('.post-content h1, .post-content h2, .post-content h3, .post-content h4, .post-content h5, .post-content h6');
  
  if (isPostPage && headings.length > 0) {
    sideNav.style.display = 'block';
    document.body.classList.add('side-nav-active');
    
    const toc = [];
    
    headings.forEach((heading, index) => {
      // Create or use existing ID
      let id = heading.id;
      if (!id) {
        // Generate ID from text content
        id = heading.textContent.trim()
          .toLowerCase()
          .replace(/[^\w\s-]/g, '') // Remove special characters
          .replace(/\s+/g, '-') // Replace spaces with hyphens
          .replace(/-+/g, '-') // Replace multiple hyphens with single
          .replace(/^-|-$/g, ''); // Remove leading/trailing hyphens
        
        // Ensure uniqueness
        let baseId = id;
        let counter = 1;
        while (document.getElementById(id)) {
          id = `${baseId}-${counter}`;
          counter++;
        }
        
        heading.id = id;
      }
      
      const level = parseInt(heading.tagName.substring(1));
      const text = heading.textContent.trim();
      
      toc.push({
        id: id,
        level: level,
        text: text,
        element: heading
      });
    });
    
    // Build nested TOC HTML structure
    function buildNestedTOC(items, minLevel = null) {
      if (items.length === 0) return '';
      
      if (minLevel === null) {
        minLevel = Math.min(...items.map(item => item.level));
      }
      
      let html = '';
      let i = 0;
      
      while (i < items.length) {
        const item = items[i];
        
        if (item.level === minLevel) {
          html += `<li class="toc-item toc-level-${item.level}">
            <a href="#${item.id}" class="toc-link" data-target="${item.id}">${item.text}</a>`;
          
          // Look for nested items
          const nestedItems = [];
          let j = i + 1;
          
          while (j < items.length && items[j].level > minLevel) {
            nestedItems.push(items[j]);
            j++;
          }
          
          if (nestedItems.length > 0) {
            html += '<ul class="toc-nested">' + buildNestedTOC(nestedItems) + '</ul>';
          }
          
          html += '</li>';
          i = j;
        } else {
          i++;
        }
      }
      
      return html;
    }
    
    tocList.innerHTML = buildNestedTOC(toc);
    
    // Add click handlers for smooth scrolling
    const tocLinks = document.querySelectorAll('.toc-link');
    tocLinks.forEach(link => {
      link.addEventListener('click', function(e) {
        e.preventDefault();
        const targetId = this.getAttribute('data-target');
        const targetElement = document.getElementById(targetId);
        
        if (targetElement) {
          // Calculate offset for fixed header if needed
          const offset = 80; // Adjust based on your header height
          const elementPosition = targetElement.getBoundingClientRect().top;
          const offsetPosition = elementPosition + window.pageYOffset - offset;
          
          window.scrollTo({
            top: offsetPosition,
            behavior: 'smooth'
          });
          
          // Update active link
          tocLinks.forEach(l => l.classList.remove('active'));
          this.classList.add('active');
        }
      });
    });
    
    // Enhanced scroll tracking with expanding/collapsing sections
    function updateActiveLink() {
      const scrollPosition = window.scrollY + 100; // Offset for better UX
      let activeHeading = null;
      let activeParentSection = null;
      
      // Find the currently visible heading
      headings.forEach(heading => {
        const rect = heading.getBoundingClientRect();
        const absoluteTop = rect.top + window.pageYOffset;
        
        if (absoluteTop <= scrollPosition) {
          activeHeading = heading;
        }
      });
      
      if (activeHeading) {
        // Find the parent section (h2) for the current heading
        const currentLevel = parseInt(activeHeading.tagName.substring(1));
        
        if (currentLevel > 2) {
          // For h3, h4, h5, h6 - find the closest preceding h2
          const headingIndex = Array.from(headings).indexOf(activeHeading);
          for (let i = headingIndex - 1; i >= 0; i--) {
            const heading = headings[i];
            if (heading.tagName === 'H2') {
              activeParentSection = heading;
              break;
            }
          }
        } else if (currentLevel === 2) {
          activeParentSection = activeHeading;
        }
      }
      
      // Update active state and expand/collapse sections
      tocLinks.forEach(link => {
        const linkTarget = link.getAttribute('data-target');
        const linkElement = document.getElementById(linkTarget);
        const linkLevel = linkElement ? parseInt(linkElement.tagName.substring(1)) : 0;
        const linkParent = link.closest('.toc-item');
        
        // Remove active class from all
        link.classList.remove('active');
        
        // Set active for current heading
        if (activeHeading && linkTarget === activeHeading.id) {
          link.classList.add('active');
        }
        
        // Handle section expansion/collapse
        const nestedList = linkParent ? linkParent.querySelector('.toc-nested') : null;
        
        if (linkLevel === 2) { // Main sections (h2)
          if (nestedList) {
            if (activeParentSection && linkTarget === activeParentSection.id) {
              // Expand this section
              nestedList.style.display = 'block';
              nestedList.style.maxHeight = 'none';
              nestedList.style.opacity = '1';
              linkParent.classList.add('expanded');
            } else {
              // Collapse this section
              nestedList.style.display = 'none';
              nestedList.style.maxHeight = '0';
              nestedList.style.opacity = '0';
              linkParent.classList.remove('expanded');
            }
          }
        }
      });
    }
    
    // Throttled scroll handler for better performance
    let scrollTimeout;
    window.addEventListener('scroll', function() {
      if (scrollTimeout) {
        clearTimeout(scrollTimeout);
      }
      scrollTimeout = setTimeout(updateActiveLink, 10);
    });
    
    // Initialize sections - collapse all except first
    function initializeSections() {
      const allSections = document.querySelectorAll('.toc-item');
      allSections.forEach((section, index) => {
        const nestedList = section.querySelector('.toc-nested');
        if (nestedList) {
          // Collapse all sections initially
          nestedList.style.display = 'none';
          nestedList.style.opacity = '0';
          nestedList.style.maxHeight = '0';
          section.classList.remove('expanded');
        }
      });
    }
    
    // Initialize sections and active link
    initializeSections();
    updateActiveLink();
    
  } else {
    sideNav.style.display = 'none';
    document.body.classList.remove('side-nav-active');
  }
});
</script>
