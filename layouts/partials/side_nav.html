<!-- Side Navigation for Table of Contents -->
<nav class="side-nav" id="side-nav">
  <div class="side-nav-content">
    <div class="side-nav-title" id="toc-title">Contents</div>
    <ul class="side-nav-list" id="toc-list">
      <!-- TOC will be populated by JavaScript -->
    </ul>
  </div>
</nav>

<script>
document.addEventListener('DOMContentLoaded', function() {
  const sideNav = document.getElementById('side-nav');
  const tocList = document.getElementById('toc-list');
  
  // Only show on blog post pages (not about, contact, etc.)
  const isPostPage = window.location.pathname.includes('/posts/');
  const headings = document.querySelectorAll('.post-content h1, .post-content h2, .post-content h3, .post-content h4, .post-content h5, .post-content h6');
  
  if (isPostPage && headings.length > 0) {
    sideNav.style.display = 'block';
    document.body.classList.add('side-nav-active');
    
    const toc = [];
    
    headings.forEach((heading, index) => {
      // Create or use existing ID
      let id = heading.id;
      if (!id) {
        // Generate ID from text content
        id = heading.textContent.trim()
          .toLowerCase()
          .replace(/[^\w\s-]/g, '') // Remove special characters
          .replace(/\s+/g, '-') // Replace spaces with hyphens
          .replace(/-+/g, '-') // Replace multiple hyphens with single
          .replace(/^-|-$/g, ''); // Remove leading/trailing hyphens
        
        // Ensure uniqueness
        let baseId = id;
        let counter = 1;
        while (document.getElementById(id)) {
          id = `${baseId}-${counter}`;
          counter++;
        }
        
        heading.id = id;
      }
      
      const level = parseInt(heading.tagName.substring(1));
      const text = heading.textContent.trim();
      
      toc.push({
        id: id,
        level: level,
        text: text,
        element: heading
      });
    });
    
    // Build nested TOC HTML structure
    function buildNestedTOC(items, minLevel = null) {
      if (items.length === 0) return '';
      
      if (minLevel === null) {
        minLevel = Math.min(...items.map(item => item.level));
      }
      
      let html = '';
      let i = 0;
      
      while (i < items.length) {
        const item = items[i];
        
        if (item.level === minLevel) {
          html += `<li class="toc-item toc-level-${item.level}">
            <a href="#${item.id}" class="toc-link" data-target="${item.id}">${item.text}</a>`;
          
          // Look for nested items
          const nestedItems = [];
          let j = i + 1;
          
          while (j < items.length && items[j].level > minLevel) {
            nestedItems.push(items[j]);
            j++;
          }
          
          if (nestedItems.length > 0) {
            html += '<ul class="toc-nested">' + buildNestedTOC(nestedItems) + '</ul>';
          }
          
          html += '</li>';
          i = j;
        } else {
          i++;
        }
      }
      
      return html;
    }
    
    tocList.innerHTML = buildNestedTOC(toc);
    
    // Add click handlers for smooth scrolling
    const tocLinks = document.querySelectorAll('.toc-link');
    tocLinks.forEach(link => {
      link.addEventListener('click', function(e) {
        e.preventDefault();
        const targetId = this.getAttribute('data-target');
        const targetElement = document.getElementById(targetId);
        
        if (targetElement) {
          targetElement.scrollIntoView({ 
            behavior: 'smooth',
            block: 'start'
          });
          
          // Update active link
          tocLinks.forEach(l => l.classList.remove('active'));
          this.classList.add('active');
        }
      });
    });
    
    // Simple scroll tracking for active highlighting
    function updateActiveLink() {
      const scrollPosition = window.scrollY + 100;
      let activeHeading = null;
      
      // Find the currently visible heading
      headings.forEach(heading => {
        const rect = heading.getBoundingClientRect();
        const absoluteTop = rect.top + window.pageYOffset;
        
        if (absoluteTop <= scrollPosition) {
          activeHeading = heading;
        }
      });
      
      // Update active state
      tocLinks.forEach(link => {
        link.classList.remove('active');
        if (activeHeading && link.getAttribute('data-target') === activeHeading.id) {
          link.classList.add('active');
        }
      });
    }
    
    // Throttled scroll handler
    let scrollTimeout;
    window.addEventListener('scroll', function() {
      if (scrollTimeout) {
        clearTimeout(scrollTimeout);
      }
      scrollTimeout = setTimeout(updateActiveLink, 10);
    });
    
    // Initialize active link
    updateActiveLink();
    
  } else {
    sideNav.style.display = 'none';
    document.body.classList.remove('side-nav-active');
  }
});
</script>
