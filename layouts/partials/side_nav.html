<!-- Side Navigation for Table of Contents -->
<nav class="side-nav" id="side-nav">
  <div class="side-nav-content">
    <div class="side-nav-title" id="toc-title">Contents</div>
    <ul class="side-nav-list" id="toc-list">
      <!-- TOC will be populated by JavaScript -->
    </ul>
  </div>
</nav>

<script>
document.addEventListener('DOMContentLoaded', function() {
  const sideNav = document.getElementById('side-nav');
  const tocList = document.getElementById('toc-list');
  
  // Only show on blog post pages (not about, contact, etc.)
  const isPostPage = window.location.pathname.includes('/posts/');
  const headings = document.querySelectorAll('.post-content h1, .post-content h2, .post-content h3, .post-content h4, .post-content h5, .post-content h6');
  
  if (isPostPage && headings.length > 0) {
    sideNav.style.display = 'block';
    document.body.classList.add('side-nav-active');
    
    const toc = [];
    
    headings.forEach((heading, index) => {
      // Create or use existing ID
      let id = heading.id;
      if (!id) {
        // Generate ID from text content
        id = heading.textContent.trim()
          .toLowerCase()
          .replace(/[^\w\s-]/g, '') // Remove special characters
          .replace(/\s+/g, '-') // Replace spaces with hyphens
          .replace(/-+/g, '-') // Replace multiple hyphens with single
          .replace(/^-|-$/g, ''); // Remove leading/trailing hyphens
        
        // Ensure uniqueness
        let baseId = id;
        let counter = 1;
        while (document.getElementById(id)) {
          id = `${baseId}-${counter}`;
          counter++;
        }
        
        heading.id = id;
      }
      
      const level = parseInt(heading.tagName.substring(1));
      const text = heading.textContent.trim();
      
      toc.push({
        id: id,
        level: level,
        text: text,
        element: heading
      });
    });
    
    // Build nested TOC HTML structure
    function buildNestedTOC(items, minLevel = null) {
      if (items.length === 0) return '';
      
      if (minLevel === null) {
        minLevel = Math.min(...items.map(item => item.level));
      }
      
      let html = '';
      let i = 0;
      
      while (i < items.length) {
        const item = items[i];
        
        if (item.level === minLevel) {
          html += `<li class="toc-item toc-level-${item.level}">
            <a href="#${item.id}" class="toc-link" data-target="${item.id}">${item.text}</a>`;
          
          // Look for nested items
          const nestedItems = [];
          let j = i + 1;
          
          while (j < items.length && items[j].level > minLevel) {
            nestedItems.push(items[j]);
            j++;
          }
          
          if (nestedItems.length > 0) {
            html += '<ul class="toc-nested">' + buildNestedTOC(nestedItems) + '</ul>';
          }
          
          html += '</li>';
          i = j;
        } else {
          i++;
        }
      }
      
      return html;
    }
    
    tocList.innerHTML = buildNestedTOC(toc);
    
    // Add click handlers for smooth scrolling
    const tocLinks = document.querySelectorAll('.toc-link');
    tocLinks.forEach(link => {
      link.addEventListener('click', function(e) {
        e.preventDefault();
        const targetId = this.getAttribute('data-target');
        const targetElement = document.getElementById(targetId);
        
        if (targetElement) {
          // Calculate offset for better positioning
          const headerHeight = 60; // Adjust based on your header height
          const extraOffset = 20; // Additional space for better reading
          const elementPosition = targetElement.getBoundingClientRect().top;
          const offsetPosition = elementPosition + window.pageYOffset - headerHeight - extraOffset;
          
          // Disable scroll tracking temporarily to prevent conflicts
          window.removeEventListener('scroll', handleScroll);
          
          window.scrollTo({
            top: Math.max(0, offsetPosition),
            behavior: 'smooth'
          });
          
          // Re-enable scroll tracking after smooth scroll completes
          setTimeout(() => {
            window.addEventListener('scroll', handleScroll, { passive: true });
            updateActiveLink(); // Update immediately after scroll
          }, 800);
          
          // Update active link immediately
          tocLinks.forEach(l => l.classList.remove('active'));
          this.classList.add('active');
        }
      });
    });
    
    // Enhanced scroll tracking with expanding/collapsing sections
    function updateActiveLink() {
      const scrollPosition = window.scrollY + window.innerHeight * 0.3; // Better offset calculation
      let activeHeading = null;
      let activeParentSection = null;
      let closestDistance = Infinity;
      
      // Find the currently visible heading with improved logic
      headings.forEach(heading => {
        const rect = heading.getBoundingClientRect();
        const absoluteTop = rect.top + window.pageYOffset;
        const distance = Math.abs(absoluteTop - scrollPosition);
        
        // Check if heading is in viewport or above current scroll position
        if (absoluteTop <= scrollPosition + 50 && distance < closestDistance) {
          activeHeading = heading;
          closestDistance = distance;
        }
      });
      
      // If no heading found above, get the first visible heading in viewport
      if (!activeHeading) {
        headings.forEach(heading => {
          const rect = heading.getBoundingClientRect();
          if (rect.top >= 0 && rect.top <= window.innerHeight && !activeHeading) {
            activeHeading = heading;
          }
        });
      }
      
      if (activeHeading) {
        // Find the parent section (h2) for the current heading
        const currentLevel = parseInt(activeHeading.tagName.substring(1));
        
        if (currentLevel > 2) {
          // For h3, h4, h5, h6 - find the closest preceding h2
          const headingIndex = Array.from(headings).indexOf(activeHeading);
          for (let i = headingIndex - 1; i >= 0; i--) {
            const heading = headings[i];
            if (heading.tagName === 'H2') {
              activeParentSection = heading;
              break;
            }
          }
        } else if (currentLevel === 2) {
          activeParentSection = activeHeading;
        }
      }
      
      // Update active state and expand/collapse sections
      tocLinks.forEach(link => {
        const linkTarget = link.getAttribute('data-target');
        const linkElement = document.getElementById(linkTarget);
        const linkLevel = linkElement ? parseInt(linkElement.tagName.substring(1)) : 0;
        const linkParent = link.closest('.toc-item');
        
        // Remove active class from all
        link.classList.remove('active');
        
        // Set active for current heading
        if (activeHeading && linkTarget === activeHeading.id) {
          link.classList.add('active');
          
          // Scroll the active link into view in the sidebar
          const sideNavRect = sideNav.getBoundingClientRect();
          const linkRect = link.getBoundingClientRect();
          
          if (linkRect.top < sideNavRect.top || linkRect.bottom > sideNavRect.bottom) {
            link.scrollIntoView({ 
              behavior: 'smooth', 
              block: 'center',
              inline: 'nearest'
            });
          }
        }
        
        // Handle section expansion/collapse
        const nestedList = linkParent ? linkParent.querySelector('.toc-nested') : null;
        
        if (linkLevel === 2) { // Main sections (h2)
          if (nestedList) {
            if (activeParentSection && linkTarget === activeParentSection.id) {
              // Expand this section
              nestedList.style.display = 'block';
              nestedList.style.maxHeight = 'none';
              nestedList.style.opacity = '1';
              linkParent.classList.add('expanded');
            } else {
              // Collapse this section
              nestedList.style.display = 'none';
              nestedList.style.maxHeight = '0';
              nestedList.style.opacity = '0';
              linkParent.classList.remove('expanded');
            }
          }
        }
      });
    }
    
    // Improved scroll handler with better performance
    let ticking = false;
    
    function requestTick() {
      if (!ticking) {
        requestAnimationFrame(updateActiveLink);
        ticking = true;
      }
    }
    
    function handleScroll() {
      requestTick();
    }
    
    // Reset ticking flag after update
    const originalUpdateActiveLink = updateActiveLink;
    updateActiveLink = function() {
      originalUpdateActiveLink();
      ticking = false;
    };
    
    // Add scroll listeners
    window.addEventListener('scroll', handleScroll, { passive: true });
    window.addEventListener('resize', handleScroll, { passive: true });
    
    // Initialize sections - collapse all except first
    function initializeSections() {
      const allSections = document.querySelectorAll('.toc-item');
      allSections.forEach((section, index) => {
        const nestedList = section.querySelector('.toc-nested');
        if (nestedList) {
          // Collapse all sections initially
          nestedList.style.display = 'none';
          nestedList.style.opacity = '0';
          nestedList.style.maxHeight = '0';
          section.classList.remove('expanded');
        }
      });
    }
    
    // Initialize sections and active link
    initializeSections();
    updateActiveLink();
    
  } else {
    sideNav.style.display = 'none';
    document.body.classList.remove('side-nav-active');
  }
});
</script>
